'CONFIG DEFINES

'Please, enable/define in your Boriel ZX Basic source code some of the following parameters
'in order to choose the features of this library that you want to use.

'Enabling this parameter tells the library that you have defined all needed parameters
'before you included the library. If this parameter is not enabled/defined, the library
'will define some parameters with standard values (such as 4 for ONSCREEN_1x2_SPRITES).
'These standard values were loaded by default into the parameters till August 2025.
'
'#define ALL_NEEDED_PARAMETERS_ALREADY_DEFINED

'Enabling this define tells the library to store unshifted sprites in SPRITE_BUFFER,
'that is, each 1x1,1x2,2x2 sprite in 8,16,32 bytes. Therefore, the library will use
'much less memory, but will be slower.
'If not enabled, the library will store shifted sprites in SPRITE_BUFFER, which is
'the default behavior: each 1x1,1x2,2x2 sprite in 48,72,120 bytes.
'
'#define STORE_UNSHIFTED_SPRITES

'Enabling this define tells the library that we are going to use precomputed sprites.
'Using precomputed sprites will help to reduce the library's memory footprint when
'your program is going to use a single sprite set.
'To generate the precomputed sprites I recommend to use the ResourceDesigner program
'that you will find in my Github repository (https://github.com/gusmanb/ResourceDesigner).
'
'#define PRECOMPUTED_SPRITES

'When PRECOMPUTED_SPRITES is enabled, sprites are included into library at compile
'time via including a file. Next parameter defines the name of this sprite file.
'Please, choose a file whose contents are compatible with value of STORE_UNSHIFTED_SPRITES:
'If STORE_UNSHIFTED_SPRITES is   defined, use a unshifted sprites file, e.g., "sprites.bas".
'If STORE_UNSHIFTED_SPRITES is undefined, use a   shifted sprites file, e.g., "Sprites.zxbas".
'
'#define SPRITES_FILE "sprites.bas"

'Enabling this define tells the library that sprite X,Y coordinates
'are measured in pixels, i.e., X can range from 0 to almost 250,
'and Y from 0 to almost 190 (0-240 and 0-176 for a 2x2 sprite).
'Coordinates for tiles are measured in characters, as usual.
'When enabled, unshifted sprites MUST be used.
'
'#define SPRITE_XY_IN_PIXELS

'Enabling this define changes the merge of the sprites and tiles to be a XOR instead of an OR
'#define MERGE_WITH_XOR

'Enabling this define activates the fast print routines
'#define ENABLE_PRINT

'The value of this parameter should be 256 bytes less than actual address
'for ROM character set (see https://skoolkid.github.io/rom/asm/3D00.html).
'You can use your own character set by setting this parameter appropriately;
'moreover, you can use 256 different characters if you define them.
'Requires ENABLE_PRINT
'#define ROM_CHARSET 3C00h

'When one of next 3 defines is not enabled, the corresponding size of sprite will not be used,
'and value of corresponding TOTAL and ONSCREEN parameters will be set to zero automatically.
'#define ENABLE_1x1_SPRITES
'#define ENABLE_1x2_SPRITES
'#define ENABLE_2x2_SPRITES

'Total number of 1x1 defined sprites
'#define TOTAL_1x1_SPRITES 4
'Total number of 1x2 defined sprites
'#define TOTAL_1x2_SPRITES 4
'Total number of 2x2 defined sprites
'#define TOTAL_2x2_SPRITES 4

'Maximum on-screen 1x1 sprites
'#define ONSCREEN_1x1_SPRITES 4
'Maximum on-screen 1x2 sprites
'#define ONSCREEN_1x2_SPRITES 4
'Maximum on-screen 2x2 sprites
'#define ONSCREEN_2x2_SPRITES 4

'If defined enables the tile system in its basic mode (tiles erased when sprite enters on it)
'#define ENABLE_TILES

'If defined tiles are merged with OR instead of erased
'Requires ENABLE_TILES
'#define MERGE_TILES

'If defined, this amount of tiles can be changed each gameloop to perform an animation
'Requires ENABLE_TILES
'#define MAX_ANIMATED_TILES_PER_SCREEN 4

'The lib by default disables interrupts, enabling this option
'will reactivate them after each call to the lib
'#define ENABLE_INTERRUPTS

'END CONFIG DEFINES

asm

#ifndef ALL_NEEDED_PARAMETERS_ALREADY_DEFINED
#define ENABLE_PRINT
#define ENABLE_1x1_SPRITES
#define ENABLE_1x2_SPRITES
#define ENABLE_2x2_SPRITES
#define TOTAL_1x1_SPRITES 4
#define TOTAL_1x2_SPRITES 8
#define TOTAL_2x2_SPRITES 4
#define ONSCREEN_1x1_SPRITES 4
#define ONSCREEN_1x2_SPRITES 4
#define ONSCREEN_2x2_SPRITES 4
#define ENABLE_TILES
#define MERGE_TILES
#define ENABLE_INTERRUPTS
#endif

;MACROS

#ifdef MERGE_WITH_XOR
#define MERGE_OP xor
#else
#define MERGE_OP or
#endif

#define CREATE_ATTRIB(ink, paper, bright, flash) (ink + (paper << 3) + (bright << 6) + (flash << 7))

#define READ_HL_POINTER(Hi,Lo) \
ld Lo, (hl) \
inc hl \
ld Hi, (hl) \
inc hl \


#define WRITE_HL_POINTER(Hi, Lo) \
ld (hl), Lo \
inc hl \
ld (hl), Hi \
inc hl \


#define WRITE_16B_ADDRESS(value, target, temp) \
ld temp, value \
ld (target), temp \


#define EXCHANGE_16B_A(regAH, regAL, regBH, regBL) \
ld a, regAH \
ld regAH, regBH \
ld regBH, a \
ld a, regAL \
ld regAL, regBL \
ld regBL, a \

#define COPY_16B_REG(sourceH, sourceL, destH, destL) \
ld destH, sourceH \
ld destL, sourceL \


#define ERASE_MEMORY(address, length) \
xor a \
ld de, address \
ld (de), a \
inc de \
ld hl, address \
ld bc, length - 1 \
ldir \


#define SHIFT_24B(first,second,third) \
srl first \
rr second \
rr third \
srl first \
rr second \
rr third \
srl first \
rr second \
rr third \
srl first \
rr second \
rr third \


#define MERGE_CHAR(source, dest) \
ld a, (source) \
MERGE_OP (dest) \
ld (dest),  a \
inc source \
inc dest \
ld a, (source) \
MERGE_OP (dest) \
ld (dest),  a \
inc source \
inc dest \
ld a, (source) \
MERGE_OP (dest) \
ld (dest),  a \
inc source \
inc dest \
ld a, (source) \
MERGE_OP (dest) \
ld (dest),  a \
inc source \
inc dest \
ld a, (source) \
MERGE_OP (dest) \
ld (dest),  a \
inc source \
inc dest \
ld a, (source) \
MERGE_OP (dest) \
ld (dest),  a \
inc source \
inc dest \
ld a, (source) \
MERGE_OP (dest) \
ld (dest),  a \
inc source \
inc dest \
ld a, (source) \
MERGE_OP (dest) \
ld (dest),  a \


#define HL_POW2_2() \
add hl, hl \
add hl, hl \


#define HL_POW2_3() \
add hl, hl \
add hl, hl \
add hl, hl \


#define HL_POW2_4() \
add hl, hl \
add hl, hl \
add hl, hl \
add hl, hl \


#define HL_POW2_5() \
add hl, hl \
add hl, hl \
add hl, hl \
add hl, hl \
add hl, hl \

#define LDI_8() \
ldi \
ldi \
ldi \
ldi \
ldi \
ldi \
ldi \
ldi \

;LIB DEFINES

#ifndef ENABLE_1x1_SPRITES

    #define TOTAL_1x1_SPRITES 0
    #define ONSCREEN_1x1_SPRITES 0

#endif

#ifndef ENABLE_1x2_SPRITES

    #define TOTAL_1x2_SPRITES 0
    #define ONSCREEN_1x2_SPRITES 0

#endif

#ifndef ENABLE_2x2_SPRITES

    #define TOTAL_2x2_SPRITES 0
    #define ONSCREEN_2x2_SPRITES 0

#endif

#ifndef ROM_CHARSET
  #define ROM_CHARSET 3C00h
#endif

#ifdef SPRITE_XY_IN_PIXELS
  #ifndef STORE_UNSHIFTED_SPRITES
    #define STORE_UNSHIFTED_SPRITES
  #endif
#endif

#ifdef STORE_UNSHIFTED_SPRITES

SPRITE_1x1_BUFFER_SIZE equ (1 * 8)
SPRITE_1x2_BUFFER_SIZE equ (2 * 8)
SPRITE_2x2_BUFFER_SIZE equ (4 * 8)

#else

SPRITE_1x1_BUFFER_SIZE equ (6 * 8)
SPRITE_1x2_BUFFER_SIZE equ (9 * 8)
SPRITE_2x2_BUFFER_SIZE equ (15 * 8)

#endif

SPRITE_1x1_SHIFTED_SIZE equ 4
SPRITE_1x2_SHIFTED_SIZE equ 6
SPRITE_2x2_SHIFTED_SIZE equ 9

TOTAL_1x1_OPS equ (ONSCREEN_1x1_SPRITES * SPRITE_1x1_SHIFTED_SIZE)
TOTAL_1x2_OPS equ (ONSCREEN_1x2_SPRITES * SPRITE_1x2_SHIFTED_SIZE)
TOTAL_2x2_OPS equ (ONSCREEN_2x2_SPRITES * SPRITE_2x2_SHIFTED_SIZE)

TOTAL_DRAW_OPS equ ((TOTAL_1x1_OPS + TOTAL_1x2_OPS + TOTAL_2x2_OPS) * 2)

#ifdef ENABLE_TILES
DRAW_OP_SIZE equ 5
#else
DRAW_OP_SIZE equ 4
#define MAX_ANIMATED_TILES_PER_SCREEN 0
#endif

#ifndef MAX_ANIMATED_TILES_PER_SCREEN
#define MAX_ANIMATED_TILES_PER_SCREEN 0
#endif

DRAW_OPS_SIZE equ ((TOTAL_DRAW_OPS + MAX_ANIMATED_TILES_PER_SCREEN * 2) * DRAW_OP_SIZE)
DRAW_OPS_DATA_SIZE equ ((TOTAL_DRAW_OPS + MAX_ANIMATED_TILES_PER_SCREEN) * 8)

SPRITE_BUFFER_SIZE equ ((TOTAL_1x1_SPRITES * SPRITE_1x1_BUFFER_SIZE)+(TOTAL_1x2_SPRITES * SPRITE_1x2_BUFFER_SIZE)+(TOTAL_2x2_SPRITES * SPRITE_2x2_BUFFER_SIZE))
SPRITE_INDEX_SIZE equ ((TOTAL_1x1_SPRITES + TOTAL_1x2_SPRITES + TOTAL_2x2_SPRITES + 1) * 2)



;JUMP TO PROG START
jp GSPRITES_LIB_END

;draw op structure:
;
;non-tiled:
;0x00 = Screen Address
;0x02 = Buffer address
;
;tiled.
;0x00 = Screen Address
;0x02 = Buffer address
;0x04 = op type (draw op = 1, tile clear op = 2)


;VARIABLES

DRAW_OPS_A:                 ;buffer de operaciones A
defs DRAW_OPS_SIZE

DRAW_OPS_B:                 ;buffer de operaciones B
defs DRAW_OPS_SIZE

DRAW_OPS_DATA:              ;buffer de datos de operaciones
defs DRAW_OPS_DATA_SIZE

CURRENT_DRAW_OPS:           ;puntero a las ops actuales
defw 0
CURRENT_CLEAR_OPS:          ;puntero a las ops de limpieza actuales
defw 0

CURRENT_DRAW_COUNT:         ;cantidad de ops actuales
defb 0
CURRENT_CLEAR_COUNT:        ;cantidad de ops de borrado actuales
defb 0

DRAW_OPS_DATA_INDEX:        ;índice de posición de escritura
defw 0

CELL_MAP_A:                 ;mapa de celdas A
defs (32 * 24)
CELL_MAP_B:                 ;mapa de celdas B
defs (32 * 24)

CURRENT_DRAW_MAP:           ;puntero a uno de los mapas de celdas que se usa para almacenar las id's de operaciones de dibujado por su posición
defw 0
CURRENT_CLEAR_MAP:          ;puntero a uno de los mapas de celdas que se usa para almacenar las id's de operaciones de limpieza por su posición
defw 0


#ifdef SPRITE_XY_IN_PIXELS
                            ;Cantidad de bytes de cada tipo (v=vacío, g=gráfico)
;SPRITE_XY_IN_PIXELS:       7v + g +...+ g + 7v
#ifdef ENABLE_1x1_SPRITES
TEMP_1x1_SPRITE:            ;Tenemos sprites 1x1:
defs 38                     ;7v + 8g + 8v + 8g + 7v = 38
#endif

#ifdef ENABLE_1x2_SPRITES

#ifndef ENABLE_2x2_SPRITES
TEMP_1x2_SPRITE:            ;Tenemos sprites 1x2 pero NO 2x2:
defs 54                     ;7v + 16g + 8v + 16g + 7v = 54
#else
TEMP_1x2_SPRITE:            ;Si tenemos sprites 1x2 AND 2x2,
TEMP_2x2_SPRITE:            ;entonces comparten espacio en RAM:
defs 78                     ;7v + 16g + 8v + 16g + 8v + 16g + 7v = 78
#endif

#else

#ifdef ENABLE_2x2_SPRITES
TEMP_2x2_SPRITE:            ;Tenemos sprites 2x2 pero NO 1x2:
defs 78                     ;7v + 16g + 8v + 16g + 8v + 16g + 7v = 78
#endif

#endif

#else
;no SPRITE_XY_IN_PIXELS

#ifdef STORE_UNSHIFTED_SPRITES
                            ;Cantidad de bytes de cada tipo (v=vacío, g=gráfico)
;STORE_UNSHIFTED_SPRITES:   4v + g +...+ g + 4v
#ifdef ENABLE_1x1_SPRITES
TEMP_1x1_SPRITE:            ;Tenemos sprites 1x1:
defs 32                     ;4v + 8g + 8v + 8g + 4v = 32
#endif

#ifdef ENABLE_1x2_SPRITES

#ifndef ENABLE_2x2_SPRITES
TEMP_1x2_SPRITE:            ;Tenemos sprites 1x2 pero NO 2x2:
defs 48                     ;4v + 16g + 8v + 16g + 4v = 48
#else
TEMP_1x2_SPRITE:            ;Si tenemos sprites 1x2 AND 2x2,
TEMP_2x2_SPRITE:            ;entonces comparten espacio en RAM:
defs 72                     ;4v + 16g + 8v + 16g + 8v + 16g + 4v = 72
#endif

#else

#ifdef ENABLE_2x2_SPRITES
TEMP_2x2_SPRITE:            ;Tenemos sprites 2x2 pero NO 1x2:
defs 72                     ;4v + 16g + 8v + 16g + 8v + 16g + 4v = 72
#endif

#endif

#endif

#endif
;end SPRITE_XY_IN_PIXELS

#ifndef SPRITES_FILE
  #ifdef PRECOMPUTED_SPRITES
    #ifdef STORE_UNSHIFTED_SPRITES
      #define SPRITES_FILE "sprites.bas"
    #else
      #define SPRITES_FILE "Sprites.zxbas"
    #endif
  #else
    #define SPRITES_FILE ""
  #endif
#endif

#ifndef PRECOMPUTED_SPRITES

SPRITE_BUFFER:              ;shifted sprite buffer
defs SPRITE_BUFFER_SIZE
SPRITE_INDEX:               ;shifted sprite indexes (stores address of each sprite)
defs SPRITE_INDEX_SIZE
SPRITE_COUNT:               ;number of created sprites
defb 0

#else

end asm

    #include SPRITES_FILE

asm

#endif

EMPTY_CHAR:
defs 8

#ifdef ENABLE_TILES
TILE_SET:
defw 0
TILE_MAP:
defs 768
#endif


;CODE

PROC 
INIT_GFX_LIB:                       ;TRASHES: HL

#ifndef ENABLE_INTERRUPTS
    di
#endif

WRITE_16B_ADDRESS(DRAW_OPS_A, CURRENT_DRAW_OPS, hl)
WRITE_16B_ADDRESS(DRAW_OPS_B, CURRENT_CLEAR_OPS, hl)

WRITE_16B_ADDRESS(DRAW_OPS_DATA, DRAW_OPS_DATA_INDEX, hl)

WRITE_16B_ADDRESS(CELL_MAP_A, CURRENT_DRAW_MAP, hl)
WRITE_16B_ADDRESS(CELL_MAP_B, CURRENT_CLEAR_MAP, hl)

WRITE_16B_ADDRESS(SPRITE_BUFFER, SPRITE_INDEX, hl)

ret
ENDP

PROC
RESET_GFX_LIB:                      ;TRASHES: HL, A

WRITE_16B_ADDRESS(DRAW_OPS_A, CURRENT_DRAW_OPS, hl)
WRITE_16B_ADDRESS(DRAW_OPS_B, CURRENT_CLEAR_OPS, hl)

WRITE_16B_ADDRESS(CELL_MAP_A, CURRENT_DRAW_MAP, hl)
WRITE_16B_ADDRESS(CELL_MAP_B, CURRENT_CLEAR_MAP, hl)

WRITE_16B_ADDRESS(DRAW_OPS_DATA, DRAW_OPS_DATA_INDEX, hl)

#ifndef PRECOMPUTED_SPRITES
ERASE_MEMORY(SPRITE_BUFFER, SPRITE_BUFFER_SIZE)
WRITE_16B_ADDRESS(SPRITE_BUFFER, SPRITE_INDEX, hl)
xor a
ld (SPRITE_COUNT), a
#endif

xor a
ld (CURRENT_DRAW_COUNT), a
ld (CURRENT_CLEAR_COUNT), a

ERASE_MEMORY(CELL_MAP_A, 768)
ERASE_MEMORY(CELL_MAP_B, 768)

#ifdef ENABLE_TILES
ERASE_MEMORY(TILE_MAP, 768)
#endif

ret
ENDP

PROC
CLEAR_SCREEN:                      ;TRASHES: HL, A

WRITE_16B_ADDRESS(DRAW_OPS_A, CURRENT_DRAW_OPS, hl)
WRITE_16B_ADDRESS(DRAW_OPS_B, CURRENT_CLEAR_OPS, hl)

WRITE_16B_ADDRESS(CELL_MAP_A, CURRENT_DRAW_MAP, hl)
WRITE_16B_ADDRESS(CELL_MAP_B, CURRENT_CLEAR_MAP, hl)

WRITE_16B_ADDRESS(DRAW_OPS_DATA, DRAW_OPS_DATA_INDEX, hl)

xor a
ld (CURRENT_DRAW_COUNT), a
ld (CURRENT_CLEAR_COUNT), a

ERASE_MEMORY(CELL_MAP_A, 768)
ERASE_MEMORY(CELL_MAP_B, 768)

#ifdef ENABLE_TILES
ERASE_MEMORY(TILE_MAP, 768)
#endif

ret
ENDP

PROC
LOCAL RENDER_LOOP, END_RENDER, RESTORE_STACK, STANDARD_OP, END_STANDARD_OP
RENDER_FRAME:                                         ;TRASHES: BC, DE, HL, A

#ifndef ENABLE_INTERRUPTS
ei
#endif
halt
#ifndef ENABLE_INTERRUPTS
di
#endif


ld a, (CURRENT_DRAW_COUNT)
cp 0
jp z, END_RENDER

ld hl, (CURRENT_DRAW_OPS)
push hl

RENDER_LOOP:

pop hl                      ;get current op address

READ_HL_POINTER(d,e)    ;get op target
READ_HL_POINTER(b,c)    ;get op source

#ifdef ENABLE_TILES
inc hl
#endif

push hl                     ;store current op address

 ld a,d     ;Check whether D = %...11... (DE in ATTRIBUTES)
 or %11100111
 inc a
 jp nz,STANDARD_OP;4+7+4+10 = 25 T-states extra per drawOP
 ld a,c     ;C = tile attributes
 ld (de),a  ;set tile color
 jp END_STANDARD_OP

STANDARD_OP:

COPY_16B_REG(b,c, h,l)        ;hl = source, de = target, stack = op address

ld (RESTORE_STACK + 1), sp      ;save stack address
ld sp, hl                       ;point stack to the op data
ex de, hl

pop de                      ;extract two bytes of data
ld (hl), e                  ;load first byte
inc h                       ;increase target address
ld (hl), d                  ;load second byte
inc h                       ;increase target address
pop de                      ;extract two bytes of data
ld (hl), e                  ;load first byte
inc h                       ;increase target address
ld (hl), d                  ;load second byte
inc h                       ;increase target address
pop de                      ;extract two bytes of data
ld (hl), e                  ;load first byte
inc h                       ;increase target address
ld (hl), d                  ;load second byte
inc h                       ;increase target address
pop de                          ;extract two bytes of data
ld (hl), e                      ;load first byte
inc h                           ;increase target address
ld (hl), d                      ;load second byte

RESTORE_STACK:
ld sp, 0                    ;Retore the data stack as we were using it for copy

END_STANDARD_OP:

;more ops left?
ld hl, CURRENT_DRAW_COUNT
dec (hl)
jp nz, RENDER_LOOP

;no, clear stack
pop bc


END_RENDER:
;frame end, swap data

ld bc, (CURRENT_DRAW_OPS)   ;swap draw and clear op
ld de, (CURRENT_CLEAR_OPS)
ld (CURRENT_DRAW_OPS), de
ld (CURRENT_CLEAR_OPS), bc

ld de, (CURRENT_DRAW_MAP)   ;swap draw and clear maps
ld bc, (CURRENT_CLEAR_MAP)
ld (CURRENT_DRAW_MAP), bc
ld (CURRENT_CLEAR_MAP), de

xor a
push de                     ;clear map
ld (de), a
inc de
pop hl
ld bc, 767
ldir

ld a, (CURRENT_CLEAR_COUNT) ;swap draw count and erase clear count
ld (CURRENT_DRAW_COUNT), a
xor a
ld (CURRENT_CLEAR_COUNT), a

WRITE_16B_ADDRESS(DRAW_OPS_DATA, DRAW_OPS_DATA_INDEX, hl) ; reset op index

ret
ENDP

#ifndef PRECOMPUTED_SPRITES

PROC
CREATE_SPRITE_BUFFER:          ;input: bc = buffer sze, output: hl = sprite buffer address, trash = bc, de, hl, a

ld a, (SPRITE_COUNT)
add a, a
ld e, a
ld d, 0
ld hl, SPRITE_INDEX
add hl, de

READ_HL_POINTER(d,e)         ;load in DE the data address
                            ;hl = next index, de = data start
push de

ex de, hl
add hl, bc
ex de, hl

WRITE_HL_POINTER(d,e)        ;store in index the next buffer start address

ld hl, SPRITE_COUNT         ;incrementar cuenta de sprites
inc (hl)

pop hl

ret
ENDP

#ifdef ENABLE_1x1_SPRITES

PROC
#ifndef STORE_UNSHIFTED_SPRITES
LOCAL LOOP
#endif
CREATE_1x1_SPRITE:          ;input: hl = sprite address, output: a = sprite number (base 1); trash= bc, de, hl, a

push hl
ld bc, SPRITE_1x1_BUFFER_SIZE
call CREATE_SPRITE_BUFFER   ;create buffer

#ifdef STORE_UNSHIFTED_SPRITES
ex de, hl
pop hl
LDI_8()
#else

ld de, 4
add hl, de                  ;skip padding bytes

pop de                      ;restore source address and preserve it again
push de

ex de, hl

LDI_8()
;ld bc, 8
;ldir                        ;copy the sprite

ld hl, 8                    ;skip bottom padding and upper padding of next column
add hl, de

ex de, hl
pop hl                      ;hl = source, de = dest

ld ixh, d                   ;copy dest to ix
ld ixl, e

ld b, 8

LOOP:

ld e, (hl)              ;load and shift byte to two bytes
ld d, 0
inc hl
ex de, hl
HL_POW2_4()
ex de, hl

ld (ix+0), d            ;write both bytes to the sprite
ld (ix+16), e
inc ix

djnz LOOP

#endif

ld a, (SPRITE_COUNT)      ;read sprite number

ret
ENDP

#endif

#ifdef ENABLE_1x2_SPRITES

PROC
#ifndef STORE_UNSHIFTED_SPRITES
LOCAL LOOP
#endif
CREATE_1x2_SPRITE:

push hl
ld bc, SPRITE_1x2_BUFFER_SIZE
call CREATE_SPRITE_BUFFER   ;create buffer

#ifdef STORE_UNSHIFTED_SPRITES
ex de, hl
pop hl
LDI_8()
LDI_8()
#else

ld de, 4
add hl, de                  ;skip padding bytes

pop de                      ;restore source address and preserve it again
push de

ex de, hl

LDI_8()
LDI_8()

;ld bc, 16
;ldir                        ;copy the sprite

ld hl, 8                    ;skip bottom padding and upper padding of next column
add hl, de

ex de, hl
pop hl                      ;hl = source, de = dest

ld ixh, d                   ;copy dest to ix
ld ixl, e

ld b, 16

LOOP:

ld e, (hl)              ;load and shift byte to two bytes
ld d, 0
inc hl
ex de, hl
HL_POW2_4()
ex de, hl

ld (ix+0), d            ;write both bytes to the sprite
ld (ix+24), e
inc ix

djnz LOOP

#endif

ld a, (SPRITE_COUNT)      ;read sprite number

ret

ENDP

#endif

#ifdef ENABLE_2x2_SPRITES

PROC
#ifndef STORE_UNSHIFTED_SPRITES
LOCAL LOOP
#endif
CREATE_2x2_SPRITE:

push hl
ld bc, SPRITE_2x2_BUFFER_SIZE
call CREATE_SPRITE_BUFFER   ;create buffer

#ifdef STORE_UNSHIFTED_SPRITES
ex de, hl
pop hl
LDI_8()
LDI_8()
LDI_8()
LDI_8()
#else

ld de, 4
add hl, de                  ;skip padding bytes

pop de                      ;restore source address and preserve it again
push de

ex de, hl

LDI_8()
LDI_8()
;ld bc, 16
;ldir                        ;copy the sprite

ex de, hl
ld bc, 8
add hl, bc

ex de, hl

LDI_8()
LDI_8()
;ld bc, 16
;ldir

ld hl, 8                    ;skip bottom padding and upper padding of next column
add hl, de
ex de, hl

pop iy                      ;iy = source, hl = dest

ld ixh, d                   ;copy dest to ix
ld ixl, e

ld b, 16

LOOP:

ld c, (iy+0)              ;load and shift
ld d, (iy+16)
ld e, 0

SHIFT_24B(c,d,e)

ld (ix+0), c                ;save shifted sprite
ld (ix+24), d
ld (ix+48), e

inc iy                      ;next src/target
inc ix

djnz LOOP

#endif

ld a, (SPRITE_COUNT)      ;read sprite number

ret
ENDP

#endif

#endif

PROC
LOCAL EXISTING_OP, REAL_EXISTING_OP
CREATE_DRAW_OP:                             ;input: b = xcol, c = yrow, hl=sprite data address. Trashes hl, bc, de, a, ix, iy

;creates a draw op using the char data at de

ld a, b
cp 32
ret nc  ;return if xcol >= 32 (or xcol < 0)
ld a, c
cp 24
ret nc  ;return if yrow >= 24 (or yrow < 0)

push hl
push bc

ld l, c                                     
ld h, 0

HL_POW2_5()                                  ;yrow * 32

ld c, b                                     ;+ xcol
ld b, 0

add hl, bc                                  ;hl cointains displacement in map

ld de, (CURRENT_DRAW_MAP)

push hl                                     ;preserve displacement

add hl, de                                  ;advance pointer to concrete cell

ld a, (hl)
and a
jp nz, EXISTING_OP                          ;a = num op

ld a, (CURRENT_DRAW_COUNT)                  ;load current draw op count
inc a                                       ;increase op number
ld (CURRENT_DRAW_COUNT), a                  ;store it in 
ld (hl), a
dec a                                       ;draw count is 1 based, not 0, so decrease 1

ld l, a
ld h, 0

#ifdef ENABLE_TILES

COPY_16B_REG(h,l, d,e)
HL_POW2_2()
add hl, de

#else
HL_POW2_2()                                   ;hl = offset, a = numop
#endif

ld bc, (CURRENT_DRAW_OPS)
add hl, bc                                  ;get current op address

pop de
pop bc
push de                                     ;hl = op address, bc = coords, stack = displacement

ld a, c
and %00011000
or  %01000000
ld d, a
ld a, c
and %00000111
rla
rla
rla
rla
rla
or b
ld e, a                                     ;de = screen address

ld ixh, d                                   ;preserve it in iy
ld ixl, e

WRITE_HL_POINTER(d,e)                        ;store it in op

ld de, (DRAW_OPS_DATA_INDEX)

ld iyh, d                                   ;preserve it in iy
ld iyl, e

WRITE_HL_POINTER(d,e)                        ;store op data address in op


#ifdef ENABLE_TILES
;ld a, 1                                     ;tag this as real op
ld (hl), 1
#endif


ld l, 8                                     ;add 8 bytes of op
ld h, 0
add hl, de

ld (DRAW_OPS_DATA_INDEX), hl                ;preserve data index

;now, create the clear op

pop bc
ld hl, (CURRENT_CLEAR_MAP)

add hl, bc                                  ;advance pointer to concrete cell

ld a, (CURRENT_CLEAR_COUNT)
inc a
ld (CURRENT_CLEAR_COUNT), a                 ;update clear count
ld (hl), a                                  ;store num op in clear map
dec a                                       ;draw count is 1 based, not 0, so decrease 1

ld l, a                                     ;compute op dispplacement
ld h, 0

#ifdef ENABLE_TILES
COPY_16B_REG(h,l, d,e)
HL_POW2_2()                                  ;num * 5
add hl, de

#else

HL_POW2_2()                                  ; num * 4

#endif

ld de, (CURRENT_CLEAR_OPS)                  ;get op address
add hl, de

ld d, ixh                                   ;restore screen address from ix
ld e, ixl

WRITE_HL_POINTER(d,e)                        ;store screen address

#ifdef ENABLE_TILES

ex de, hl                                   ;de contains pointer to op
ld hl, TILE_MAP                             ;load tile map address
add hl, bc                                  ;add displacement
ld a, (hl)

ld l, a
ld h, 0

HL_POW2_3()

ld bc, (TILE_SET)
add hl, bc
ex de, hl

WRITE_HL_POINTER(d,e)                        ;store data address

;ld a, 2                                     ;tag this as clear op
ld (hl), 2

#else


ld de, EMPTY_CHAR
WRITE_HL_POINTER(d,e)                        ;store data address

#endif


pop hl


#ifdef MERGE_TILES


ld b, iyh
ld c, iyl
;de = tile source, bc = buffer, hl = sprite address

;hl = sprite address, de = buffer address, bc = tile address

ld a, (de)
    MERGE_OP (hl)
    ld (bc), a
    inc bc
    inc de
    inc hl
ld a, (de)
    MERGE_OP (hl)
    ld (bc), a
    inc bc
    inc de
    inc hl
ld a, (de)
    MERGE_OP (hl)
    ld (bc), a
    inc bc
    inc de
    inc hl
ld a, (de)
    MERGE_OP (hl)
    ld (bc), a
    inc bc
    inc de
    inc hl
ld a, (de)
    MERGE_OP (hl)
    ld (bc), a
    inc bc
    inc de
    inc hl
ld a, (de)
    MERGE_OP (hl)
    ld (bc), a
    inc bc
    inc de
    inc hl
ld a, (de)
    MERGE_OP (hl)
    ld (bc), a
    inc bc
    inc de
    inc hl

    ld a, (de)
    MERGE_OP (hl)
    ld (bc), a

#else
ld d, iyh                                   ;finally, we copy the char data to the op
ld e, iyl

LDI_8()
;ld bc, 8
;ldir
#endif

ret 

EXISTING_OP:                                ;a = op number

dec a

ld l, a
ld h, 0

#ifdef ENABLE_TILES

COPY_16B_REG(h,l, d,e)
HL_POW2_2()
add hl, de

#else
HL_POW2_2()                                   ;hl = offset, a = numop
#endif

ld bc, (CURRENT_DRAW_OPS)

add hl, bc                                  ;get current op address

READ_HL_POINTER(b,c)                         ;store screen address

push hl                                     ;store op address
push bc                                     ;store screen address

READ_HL_POINTER(d,e)                         ;de contains the data address

#ifdef ENABLE_TILES

push de                                     ;store tile address

ld a, (hl)
and 2
jp z, REAL_EXISTING_OP
;ld a, 1
ld (hl), 1
#else

ld hl, EMPTY_CHAR
sbc hl, de                                  ;test if address is the empty char
jp nz, REAL_EXISTING_OP

#endif

;this was a clear op
;create the clear op for the new op

;stack contains:
;screen address
;op address
;displacement
;coordinates
;sprite address

#ifdef ENABLE_TILES
pop af
#endif

pop bc                          ;screen address
pop de                          ;op address
pop hl                          ;displacement
push de

#ifdef ENABLE_TILES
push af
#endif

;stack contains:
;displacement (only if tiles enabled)
;op address
;coordinates
;sprite address

ld de, (CURRENT_CLEAR_MAP)
add hl, de                      ;add displacement to the map coords

ld a, (CURRENT_CLEAR_COUNT)     ;read current clear count
inc a                           ;increment it
ld (hl), a                      ;store it in the map
ld (CURRENT_CLEAR_COUNT), a     ;update variable

dec a                           ;get clear op address
ld l, a
ld h, 0

#ifdef ENABLE_TILES

COPY_16B_REG(h,l, d,e)
HL_POW2_2()
add hl, de

#else
HL_POW2_2()                                   ;hl = offset, a = numop
#endif

ld de, (CURRENT_CLEAR_OPS)
add hl, de

WRITE_HL_POINTER(b,c)            ;store screen address

#ifdef ENABLE_TILES

pop de
WRITE_HL_POINTER(d,e)                        ;store data address

;ld a, 2                                     ;tag this as clear op
ld (hl), 2

#else


ld de, EMPTY_CHAR
WRITE_HL_POINTER(d,e)                        ;store data address

#endif

pop hl

#ifdef MERGE_TILES
push de
#endif

ld de, (DRAW_OPS_DATA_INDEX)

;push de                                     ;store buffer address

WRITE_HL_POINTER(d,e)                        ;store data address in op

ld hl, 8
add hl, de

ld (DRAW_OPS_DATA_INDEX), hl                ;increment data index

#ifdef MERGE_TILES
pop bc                                      ;restore source address
#endif

pop hl                                      ;clear stack
pop hl                                      ;copy the data to the op

#ifdef MERGE_TILES

;hl = sprite address, de = buffer address, bc = tile address

ld a, (bc)
    MERGE_OP (hl)
    ld (de), a
    inc bc
    inc de
    inc hl
ld a, (bc)
    MERGE_OP (hl)
    ld (de), a
    inc bc
    inc de
    inc hl
ld a, (bc)
    MERGE_OP (hl)
    ld (de), a
    inc bc
    inc de
    inc hl
ld a, (bc)
    MERGE_OP (hl)
    ld (de), a
    inc bc
    inc de
    inc hl
ld a, (bc)
    MERGE_OP (hl)
    ld (de), a
    inc bc
    inc de
    inc hl
ld a, (bc)
    MERGE_OP (hl)
    ld (de), a
    inc bc
    inc de
    inc hl
ld a, (bc)
    MERGE_OP (hl)
    ld (de), a
    inc bc
    inc de
    inc hl

    ld a, (bc)
    MERGE_OP (hl)
    ld (de), a

#else
LDI_8()
;ld bc, 8
;ldir
#endif

ret

REAL_EXISTING_OP:                           ;not empty char

pop hl                                      ;clear stack
pop hl                                      ;clear stack
pop hl                                      ;clear stack
pop hl                                      ;clear stack

#ifdef ENABLE_TILES
pop hl                                      ;clear stack
#endif

pop hl                                      ;retrieve sprite address

ex de, hl

MERGE_CHAR(de, hl)                          ;merge op

ret

ENDP


PROC
LOCAL LOOP
DRAW_SPRITE_COLUMN:         ;input: hl = column start address, bc = coordinates, a = column char height

LOOP

push hl
push bc
ex af, af'

call CREATE_DRAW_OP

pop bc
pop hl

inc c
ld de, 8
add hl, de

ex af, af'

dec a
jr nz, LOOP

ret
ENDP

PROC

UBYTE_COORDS_TO_BCHL:
; N = 2 or 8 depending on SPRITE_XY_IN_PIXELS is not defined or defined
; input: a = sprite number, b = X [0,63] or [0,255], d = Y [0,47] or [0,191]
;output: a = sprite number, b = XmodN = XintoCharPos, h = Int(X/N) = column
;                           c = YmodN = YintoCharPos, l = Int(Y/N) = row
 ex af,af'

 ld a,b;    X
 srl b
#ifdef SPRITE_XY_IN_PIXELS
    srl b
    srl b
#endif
 ld h,b;    h = Int(X/N) = column
#ifdef SPRITE_XY_IN_PIXELS
    and 7
#else
    and 1
#endif
 ld b,a;    b = XmodN = XintoCharPos

 ld a,d;    Y
 srl d
#ifdef SPRITE_XY_IN_PIXELS
    srl d
    srl d
#endif
 ld l,d;    l = Int(Y/N) = row
#ifdef SPRITE_XY_IN_PIXELS
    and 7
#else
    and 1
#endif
 ld c,a;    c = YmodN = YintoCharPos

 ex af,af'
 ret

ENDP

#ifdef SPRITE_XY_IN_PIXELS

PROC

INTEGER_COORDS_TO_BCHL:
; input: a = sprite number, bc = X [-15,255], de = Y [-15,191]
;output: a = sprite number, b = Xmod8 = XintoCharPos, h = Int(X/8) = column
;                           c = Ymod8 = YintoCharPos, l = Int(Y/8) = row
 ex af,af'

 ld a,c;    If bc = -15, then c = -15 (and b = 255)
 sra b
 rra;       a = -8
 sra b
 rra;       a = -4
 sra b
 rra;       a = -2
 ld h,a;    h = Int(X/8) = column
 ld a,c
 and 7
 ld b,a;    b = Xmod8 = XintoCharPos

 ld a,e;    If de = 191, then e = 191 (and d = 0)
 sra d
 rra;       a = 95
 sra d
 rra;       a = 47
 sra d
 rra;       a = 23
 ld l,a;    l = Int(Y/8) = row
 ld a,e
 and 7
 ld c,a;    c = Ymod8 = YintoCharPos

 ex af,af'
 ret

ENDP

#endif

#ifdef ENABLE_1x1_SPRITES

PROC
LOCAL TEST_SHIFTS, HORIZONTAL_SHIFT, VERTICAL_SHIFT
DRAW_1x1_SPRITE:
; N = 2 or 8 depending on SPRITE_XY_IN_PIXELS is not defined or defined
; input: a = sprite number, b = XmodN = XintoCharPos, h = Int(X/N) = column
;                           c = YmodN = YintoCharPos, l = Int(Y/N) = row
push hl

dec a
add a, a
ld l, a
ld h, 0
ld de, SPRITE_INDEX
add hl, de

READ_HL_POINTER(d,e)    ;de contains the sprite data

#ifdef STORE_UNSHIFTED_SPRITES
ld a, 8
ex af, af'; A'=8 for HSHIFT1to7_1xN_SPRITE and HSHIFT4_1xN_SPRITE
#endif
ld a, b
or c

jp nz, TEST_SHIFTS

;unshifted sprite
pop bc                      ;calculate row/col

#ifdef STORE_UNSHIFTED_SPRITES
ex de, hl
#else
ld hl, 4
add hl, de                  ;hl = sprite data address
#endif

call CREATE_DRAW_OP         ;create op

ret

TEST_SHIFTS:
ld a, c
and a
jp z, HORIZONTAL_SHIFT
ld a, b
and a
jp z, VERTICAL_SHIFT

;diagonal shift

#ifdef SPRITE_XY_IN_PIXELS
ld ix, TEMP_1x1_SPRITE + 7
ld iyl, c
call HSHIFT1to7_1xN_SPRITE
ld e, iyl
ld d, 0;    DE = Ymod8 = 1,2,3,4,5,6,7
ld hl, TEMP_1x1_SPRITE + 7
sbc hl, de; HL=TEMP_1x1_SPRITE + 6,5,4,3,2,1,0
#else

#ifdef STORE_UNSHIFTED_SPRITES
ld ix, TEMP_1x1_SPRITE + 4
call HSHIFT4_1xN_SPRITE
ld hl, TEMP_1x1_SPRITE
#else
ld hl, 16
add hl, de
#endif

#endif
pop bc                      ;calculate row/col

push bc                     ;store coords
;push hl                     ;store data address

ld a, 2
call DRAW_SPRITE_COLUMN

ld a,2
pop bc
inc b
call DRAW_SPRITE_COLUMN

ret

HORIZONTAL_SHIFT:

#ifdef SPRITE_XY_IN_PIXELS
ld ix, TEMP_1x1_SPRITE + 7
call HSHIFT1to7_1xN_SPRITE
ld hl, TEMP_1x1_SPRITE + 7
#else

#ifdef STORE_UNSHIFTED_SPRITES
ld ix, TEMP_1x1_SPRITE + 4
call HSHIFT4_1xN_SPRITE
ld hl, TEMP_1x1_SPRITE + 4
#else
ld hl, 20                   ;skip 32 bytes; 12 bytes of padding and 1 char
add hl, de                  ;hl now contains first line of real data
#endif

#endif
pop bc                      ;calculate col/row

push bc                     ;store coords
push hl                     ;store data address

call CREATE_DRAW_OP         ;create first op

pop hl
pop bc                      ;restore col/row
inc b                       ;next col


ld de, 16                   ;skip 16 bytes, 8 bytes of padding and one char
add hl, de

call CREATE_DRAW_OP         ;create second op

ret

VERTICAL_SHIFT:

#ifdef SPRITE_XY_IN_PIXELS
ex de, hl
ld de, TEMP_1x1_SPRITE + 7
ld a, c
LDI_8()
ld e, a
ld d, 0;    DE = Ymod8 = 1,2,3,4,5,6,7
ld hl, TEMP_1x1_SPRITE + 7
sbc hl, de; HL=TEMP_1x1_SPRITE + 6,5,4,3,2,1,0
#else

ex de, hl
#ifdef STORE_UNSHIFTED_SPRITES
ld de, TEMP_1x1_SPRITE + 4
LDI_8()
ld hl, TEMP_1x1_SPRITE
#endif

#endif
pop bc                      ;calculate row/col

ld a, 2
call DRAW_SPRITE_COLUMN

ret
ENDP

#endif

#ifdef ENABLE_1x2_SPRITES

PROC
LOCAL TEST_SHIFTS, HORIZONTAL_SHIFT, VERTICAL_SHIFT
DRAW_1x2_SPRITE:
; N = 2 or 8 depending on SPRITE_XY_IN_PIXELS is not defined or defined
; input: a = sprite number, b = XmodN = XintoCharPos, h = Int(X/N) = column
;                           c = YmodN = YintoCharPos, l = Int(Y/N) = row
push hl

dec a
add a, a
ld l, a
ld h, 0
ld de, SPRITE_INDEX
add hl, de

READ_HL_POINTER(d,e)    ;de contains the sprite data

#ifdef STORE_UNSHIFTED_SPRITES
ld a, 16
ex af, af'; A'=16 for HSHIFT1to7_1xN_SPRITE and HSHIFT4_1xN_SPRITE
#endif
ld a, b
or c

jp nz, TEST_SHIFTS

;unshifted sprite
pop bc                      ;calculate row/col

#ifdef STORE_UNSHIFTED_SPRITES
ex de, hl
#else
ld hl, 4
add hl, de                  ;hl = sprite data address
#endif

ld a, 2
call DRAW_SPRITE_COLUMN

ret

TEST_SHIFTS:
ld a, c
and a
jp z, HORIZONTAL_SHIFT
ld a, b
and a
jp z, VERTICAL_SHIFT

;diagonal shift

#ifdef SPRITE_XY_IN_PIXELS
ld ix, TEMP_1x2_SPRITE + 7
ld iyl, c
call HSHIFT1to7_1xN_SPRITE
ld e, iyl
ld d, 0;    DE = Ymod8 = 1,2,3,4,5,6,7
ld hl, TEMP_1x2_SPRITE + 7
sbc hl, de; HL=TEMP_1x2_SPRITE + 6,5,4,3,2,1,0
#else

#ifdef STORE_UNSHIFTED_SPRITES
ld ix, TEMP_1x2_SPRITE + 4
call HSHIFT4_1xN_SPRITE
ld hl, TEMP_1x2_SPRITE
#else
ld hl, 24
add hl, de
#endif

#endif
pop bc                      ;calculate row/col

push bc                     ;store coords
ld a, 3
call DRAW_SPRITE_COLUMN

ld a,3
pop bc
inc b
call DRAW_SPRITE_COLUMN

ret

HORIZONTAL_SHIFT:

#ifdef SPRITE_XY_IN_PIXELS
ld ix, TEMP_1x2_SPRITE + 7
call HSHIFT1to7_1xN_SPRITE
ld hl, TEMP_1x2_SPRITE + 7
#else

#ifdef STORE_UNSHIFTED_SPRITES
ld ix, TEMP_1x2_SPRITE + 4
call HSHIFT4_1xN_SPRITE
ld hl, TEMP_1x2_SPRITE + 4
#else
ld hl, 28                   ;skip 32 bytes; 12 bytes of padding and 1 char
add hl, de                  ;hl now contains first line of real data
#endif

#endif
pop bc                      ;calculate col/row

push bc                     ;store coords
ld a,2
call DRAW_SPRITE_COLUMN     ;create first column

pop bc                      ;restore col/row
inc b                       ;next col
ld de, 8                    ;skip padding
add hl, de
ld a, 2
call DRAW_SPRITE_COLUMN         ;create second op

ret

VERTICAL_SHIFT:

#ifdef SPRITE_XY_IN_PIXELS
ex de, hl
ld de, TEMP_1x2_SPRITE + 7
ld a, c
LDI_8()
LDI_8()
ld e, a
ld d, 0;    DE = Ymod8 = 1,2,3,4,5,6,7
ld hl, TEMP_1x2_SPRITE + 7
sbc hl, de; HL=TEMP_1x2_SPRITE + 6,5,4,3,2,1,0
#else

ex de, hl
#ifdef STORE_UNSHIFTED_SPRITES
ld de, TEMP_1x2_SPRITE + 4
LDI_8()
LDI_8()
ld hl, TEMP_1x2_SPRITE
#endif

#endif
pop bc                      ;calculate row/col
ld a, 3
call DRAW_SPRITE_COLUMN

ret
ENDP

#endif

#ifdef ENABLE_1x1_SPRITES
#define ENABLE_1xN_SPRITES
#endif

#ifdef ENABLE_1x2_SPRITES
#ifndef ENABLE_1xN_SPRITES
#define ENABLE_1xN_SPRITES
#endif
#endif

#ifdef ENABLE_1xN_SPRITES

#ifdef SPRITE_XY_IN_PIXELS

PROC
LOCAL A123, SHIFTL, SHIFTR, LOOP_L, LOOP_R, LDIXL, LDIXR
HSHIFT1to7_1xN_SPRITE:
; Input: a' = 8 or 16, b = Xmod8, c = Ymod8, ix = TEMPdest, de = graphdir
; Destroys bc
; Constraints: b should not be 0
 ld a,b
 cp 4
 jr c,A123; 3/8

;A4567      8-a = 4,3,2,1 shifts to the left, 3bytes/shift
 add a,a
 add a,b;   a = 12,15,18,21
 ld hl, SHIFTL - 12
 ld b,0
 ld c,a;    bc = a
 add hl,bc; hl = SHIFTL,SHIFTL+3,SHIFTL+6,SHIFTL+9
 ex af,af'; 8 or 16 in a
 ld b,a
 add a,8;   a = 16 or 24
 ld (LDIXL+2),a

LOOP_L:
 ld a,(de)
 ld c,a
 xor a
 jp (hl);   jp hl is 6TS quicker than jp nn
SHIFTL:
 rl c
 rla
 rl c;      SHIFTL+3
 rla
 rl c;      SHIFTL+6
 rla
 rl c;      SHIFTL+9
 rla
 ld (ix+0),a
LDIXL:
 ld (ix+0),c; actually ix+16 or ix+24
 inc de
 inc ix
djnz LOOP_L
 ret

;A123       a = 1,2,3 shifts to the right, 3bytes/shift
A123:
 ld c,a
 add a,a
 add a,c;   a = 3,6,9
 ld hl, SHIFTR + 9
 ld b,0
 ld c,a;    bc = a
 sbc hl,bc; hl = SHIFTR+6,SHIFTR+3,SHIFTR
 ex af,af'; 8 or 16 in A
 ld b,a
 add a,8;   a = 16 or 24
 ld (LDIXR+2),a

LOOP_R:
 ld a,(de)
 ld c,a
 xor a
 jp (hl);   jp hl is 6TS quicker than jp nn
SHIFTR:
 rr c
 rra
 rr c;      SHIFTR+3
 rra
 rr c;      SHIFTR+6
 rra
 ld (ix+0),c
LDIXR:
 ld (ix+0),a; actually ix+16 or ix+24
 inc de
 inc ix
 djnz LOOP_R
 ret

ENDP

#else

#ifdef STORE_UNSHIFTED_SPRITES

PROC
LOCAL LOOP, LDIX
HSHIFT4_1xN_SPRITE:
; Input: a' = 8 or 16, ix = TEMPdest, de = graphdir
 ex af,af'; 8 or 16 in A
 ld b,a
 add a,8;   a = 16 or 24
 ld (LDIX+2),a

LOOP:
 ld a,(de)
 ld l,a
 xor a
 rl l
 rla
 rl l
 rla
 rl l
 rla
 rl l
 rla
 ld (ix+0),a
LDIX:
 ld (ix+0),l; actually ix+16 or ix+24
 inc de
 inc ix
djnz LOOP
 ret

ENDP

#endif

#endif

#endif

#ifdef ENABLE_2x2_SPRITES

PROC
LOCAL TEST_SHIFTS, HORIZONTAL_SHIFT, VERTICAL_SHIFT
DRAW_2x2_SPRITE:
; N = 2 or 8 depending on SPRITE_XY_IN_PIXELS is not defined or defined
; input: a = sprite number, b = XmodN = XintoCharPos, h = Int(X/N) = column
;                           c = YmodN = YintoCharPos, l = Int(Y/N) = row
push hl

dec a
add a, a
ld l, a
ld h, 0
ld de, SPRITE_INDEX
add hl, de

READ_HL_POINTER(d,e)    ;de contains the sprite data

ld a, b
or c

jp nz, TEST_SHIFTS

;unshifted sprite
pop bc                      ;calculate row/col

#ifdef STORE_UNSHIFTED_SPRITES
ex de, hl
#else
ld hl, 4
add hl, de                  ;hl = sprite data address
#endif

push bc

ld a, 2
call DRAW_SPRITE_COLUMN

pop bc
inc b
#ifndef STORE_UNSHIFTED_SPRITES
ld de, 8
add hl, de
#endif
ld a, 2
call DRAW_SPRITE_COLUMN

ret

TEST_SHIFTS:
ld a, c
and a
jp z, HORIZONTAL_SHIFT
ld a, b
and a
jp z, VERTICAL_SHIFT

;diagonal shift

#ifdef SPRITE_XY_IN_PIXELS
call HSHIFT1to7_2x2_SPRITE
ld e, c
ld d, 0;    DE = Ymod8 = 1,2,3,4,5,6,7
ld hl, TEMP_2x2_SPRITE + 7
sbc hl, de; HL=TEMP_2x2_SPRITE + 6,5,4,3,2,1,0
#else

#ifdef STORE_UNSHIFTED_SPRITES
call HSHIFT4_2x2_SPRITE
ld hl, TEMP_2x2_SPRITE
#else
ld hl, 48
add hl, de
#endif

#endif
pop bc                      ;calculate row/col

push bc                     ;store coords
ld a, 3
call DRAW_SPRITE_COLUMN     ;draw column

ld a,3                      ;next column
pop bc
inc b
push bc
call DRAW_SPRITE_COLUMN

ld a,3                      ;last column
pop bc
inc b
call DRAW_SPRITE_COLUMN

ret

HORIZONTAL_SHIFT:

#ifdef SPRITE_XY_IN_PIXELS
call HSHIFT1to7_2x2_SPRITE
ld hl, TEMP_2x2_SPRITE + 7
#else

#ifdef STORE_UNSHIFTED_SPRITES
call HSHIFT4_2x2_SPRITE
ld hl, TEMP_2x2_SPRITE + 4
#else
ld hl, 52                   ;skip 32 bytes; 12 bytes of padding and 1 char
add hl, de                  ;hl now contains first line of real data
#endif

#endif
pop bc                      ;calculate col/row

push bc                     ;store coords
ld a,2                      ;column is 2 chars height
call DRAW_SPRITE_COLUMN     ;create first column

pop bc                      ;restore col/row
inc b                       ;next col
push bc                     ;store for next col
ld de, 8                    ;skip padding
add hl, de
ld a, 2                     
call DRAW_SPRITE_COLUMN     ;create second column

pop bc                      ;restore col/row
inc b                       ;next col
ld de, 8                    ;skip padding
add hl, de
ld a, 2
call DRAW_SPRITE_COLUMN     ;create last column

ret

VERTICAL_SHIFT:

#ifdef SPRITE_XY_IN_PIXELS
ex de, hl
ld de, TEMP_2x2_SPRITE + 7
ld a, c
LDI_8()
LDI_8()
ld de, TEMP_2x2_SPRITE + 31
LDI_8()
LDI_8()
ld e, a
ld d, 0;    DE = Ymod8 = 1,2,3,4,5,6,7
ld hl, TEMP_2x2_SPRITE + 7
sbc hl, de; HL=TEMP_2x2_SPRITE + 6,5,4,3,2,1,0
#else

ex de, hl
#ifdef STORE_UNSHIFTED_SPRITES
ld de, TEMP_2x2_SPRITE + 4
push bc
LDI_8()
LDI_8()
ld de, TEMP_2x2_SPRITE + 28
LDI_8()
LDI_8()
pop bc
ld hl, TEMP_2x2_SPRITE
#endif

#endif
pop bc                      ;calculate row/col

ld a, 3
push bc
call DRAW_SPRITE_COLUMN     ;draw first row

ld a, 3
pop bc
inc b
call DRAW_SPRITE_COLUMN     ;draw second row

ret
ENDP

#ifdef SPRITE_XY_IN_PIXELS

PROC
LOCAL A123, SHIFTL, SHIFTR, LOOP_L, LOOP_R
HSHIFT1to7_2x2_SPRITE:
; Input: b = Xmod8, c = Ymod8, de = graphdir
; Destroys b
; Constraints: b should not be 0
 ld iyh,d
 ld iyl,e
 ld ix, TEMP_2x2_SPRITE + 7
 ld a,b
 cp 4
 ld b,16
 jr c,A123; 3/8

;A4567      8-a = 4,3,2,1 shifts to the left, 2bytes/shift
 add a,a;   a = 8,10,12,14
 ld hl, SHIFTL - 8
 ld d,0
 ld e,a;    de = a
 add hl,de; hl = SHIFTL,SHIFTL+2,SHIFTL+4,SHIFTL+6
 ld (SHIFTL - 2),hl

LOOP_L:
 ld h,(iy+0)
 ld l,(iy+16)
 xor a
 jp $1234;  jp SHIFTL,SHIFTL+2,SHIFTL+4,SHIFTL+6
SHIFTL:
 add hl,hl; add hl,hl is 5TS quicker than rl l + rl h
 rla
 add hl,hl; SHIFTL+2
 rla
 add hl,hl; SHIFTL+4
 rla
 add hl,hl; SHIFTL+6
 rla
 ld (ix+0),a
 ld (ix+24),h
 ld (ix+48),l
 inc iy
 inc ix
 djnz LOOP_L
 ret

;A123       a = 1,2,3 shifts to the right, 5bytes/shift
A123:
 ld e,a
 add a,a
 add a,a
 add a,e;   a = 5,10,15
 ld hl, SHIFTR + 15
 ld d,0
 ld e,a;    de = a
 sbc hl,de; hl = SHIFTR+10,SHIFTR+5,SHIFTR
 ld b,16

LOOP_R:
 ld d,(iy+0)
 ld e,(iy+16)
 xor a
 jp (hl);   jp hl is 6TS quicker than jp nn
SHIFTR:
 rr d
 rr e
 rra
 rr d;      SHIFTR+5
 rr e
 rra
 rr d;      SHIFTR+10
 rr e
 rra
 ld (ix+0),d
 ld (ix+24),e
 ld (ix+48),a
 inc iy
 inc ix
 djnz LOOP_R
 ret

ENDP

#else

#ifdef STORE_UNSHIFTED_SPRITES

PROC
LOCAL LOOP
HSHIFT4_2x2_SPRITE:
; Input: de = graphdir
; Destroys b
 ld iyh,d
 ld iyl,e
 ld ix, TEMP_2x2_SPRITE + 4
 ld b,16

LOOP:
 ld h,(iy+0)
 ld l,(iy+16)
 xor a
 add hl,hl; add hl,hl is 5TS quicker than rl l + rl h
 rla
 add hl,hl
 rla
 add hl,hl
 rla
 add hl,hl
 rla
 ld (ix+0),a
 ld (ix+24),h
 ld (ix+48),l
 inc iy
 inc ix
 djnz LOOP
 ret

ENDP

#endif

#endif

#endif

#ifdef ENABLE_PRINT

PROC
PRINT_CHAR:               ;input: a = char number, c = color, e = x, l = y, trashes bc, de, hl, a


HL_POW2_5()              ;y * 32

add hl, de              ;+ x

ex de, hl

ld hl, $5800
add hl, de
ld (hl), c              ;set tile color


ld l, a                 ;get tile source address
ld h, 0

HL_POW2_3()

ld bc, ROM_CHARSET
add hl, bc


ld a, d                 ;calculate screen address
rla
rla
rla
or %01000000
ld d, a

ld a, (hl)
    ld (de), a
    inc hl
    inc d
ld a, (hl)
    ld (de), a
    inc hl
    inc d
ld a, (hl)
    ld (de), a
    inc hl
    inc d
ld a, (hl)
    ld (de), a
    inc hl
    inc d
ld a, (hl)
    ld (de), a
    inc hl
    inc d
ld a, (hl)
    ld (de), a
    inc hl
    inc d
ld a, (hl)
    ld (de), a
    inc hl
    inc d

ld a, (hl)
ld (de), a

ret
ENDP

#endif

#ifdef ENABLE_TILES
PROC
SET_TILEMAP:            ;input: hl = tile set address, trashes de, hl

ld de, TILE_SET
ex de, hl
WRITE_HL_POINTER(d,e)

ret
ENDP

PROC
SET_TILE:               ;input: a = tile number, c = color, e = x, l = y, trashes bc, de, hl, a


HL_POW2_5()              ;y * 32

add hl, de              ;+ x

ex de, hl

ld hl, TILE_MAP
add hl, de              ;+ tile_map address

ld (hl), a              ;set tile number

ld hl, $5800
add hl, de
ld (hl), c              ;set tile color


ld l, a                 ;get tile source address
ld h, 0

HL_POW2_3()

ld bc, (TILE_SET)
add hl, bc


ld a, d                 ;calculate screen address
rla
rla
rla
or %01000000
ld d, a

ld a, (hl)
    ld (de), a
    inc hl
    inc d
ld a, (hl)
    ld (de), a
    inc hl
    inc d
ld a, (hl)
    ld (de), a
    inc hl
    inc d
ld a, (hl)
    ld (de), a
    inc hl
    inc d
ld a, (hl)
    ld (de), a
    inc hl
    inc d
ld a, (hl)
    ld (de), a
    inc hl
    inc d
ld a, (hl)
    ld (de), a
    inc hl
    inc d

ld a, (hl)
ld (de), a

ret
ENDP

PROC
SET_TILE_COLOR:              ;input: c = color, e = x, l = y, trashes bc, de, hl, a


HL_POW2_5()              ;y * 32

add hl, de              ;+ x
ex de, hl
ld hl, $5800
add hl, de
ld (hl), c              ;set tile color

ret

ENDP

PROC
GET_TILE_COLOR:              ;input: e = x, l = y, trashes de, hl, a, output: a = color


HL_POW2_5()              ;y * 32

add hl, de              ;+ x
ex de, hl
ld hl, $5800
add hl, de
ld a, (hl)

ret

ENDP

PROC
LOCAL REAL_OP, NO_OP, END_SET

SET_TILE_CHECKED:       ;input: a = tile number, c = color, e = x, l = y, trashes bc, de, hl, a

HL_POW2_5()             ;y * 32

add hl, de              ;+ x

push hl                 ;store displacement for later check of clear ops

ex de, hl

ld hl, TILE_MAP
add hl, de              ;+ tile_map address

ld (hl), a              ;set tile number

ld hl, $5800
add hl, de
ld (hl), c              ;set tile color


ld l, a                 ;get tile source address
ld h, 0

HL_POW2_3()

ld bc, (TILE_SET)
add hl, bc

push hl                 ;store tile source address for later check

pop bc                                  ;tile source address
pop hl                                  ;displacement

push hl
push de
push bc                                ;preserve tile source address

ld de, (CURRENT_DRAW_MAP)

add hl, de                             ;advance pointer to concrete cell

ld a, (hl)
and a
jp z, NO_OP                            ;a = num op

REAL_OP:

dec a

ld l, a
ld h, 0

COPY_16B_REG(h,l, d,e)
HL_POW2_2()
add hl, de                                  ;hl = offset, a = numop

ld bc, (CURRENT_DRAW_OPS)

add hl, bc                                  ;get current op address

inc hl
inc hl

pop de

WRITE_HL_POINTER(d, e)

ld a, 2
ld (hl), a

pop de                                  ;cleanup
pop de                                  ;cleanup

jp END_SET

NO_OP:

pop hl
pop de
pop bc

ld a, d                 ;calculate screen address
rla
rla
rla
or %01000000
ld d, a

ld a, (hl)
    ld (de), a
    inc hl
    inc d
ld a, (hl)
    ld (de), a
    inc hl
    inc d
ld a, (hl)
    ld (de), a
    inc hl
    inc d
ld a, (hl)
    ld (de), a
    inc hl
    inc d
ld a, (hl)
    ld (de), a
    inc hl
    inc d
ld a, (hl)
    ld (de), a
    inc hl
    inc d
ld a, (hl)
    ld (de), a
    inc hl
    inc d

ld a, (hl)
ld (de), a

END_SET:

ret
ENDP

PROC
LOCAL CREATE_OP
SET_TILE_ANIMATED:  ;input: a = tile number, c = color, e = x, l = y, trashes bc, de, hl, a

; Compute displacement in maps of 768 bytes, and push x,y
 ld b,l     ;y
 HL_POW2_5();y*32
 add hl,de  ;y*32 + x = displacement in maps of 768 bytes
 ld d,e
 ld e,b
 push de    ;D = x, E = y

; Set tile number in tile map, and compute attributes address
 ex de,hl   ;DE = displacement in maps of 768 bytes
 ld hl,TILE_MAP
 add hl,de
 ld (hl),a  ;set tile number
 ld hl,$5800;beginning of ATTRIBUTES, H = %...11...
 add hl,de
;ld (hl),c  ;set tile color
 push bc    ;C = tile attributes
 push hl    ;HL = attributes address

; Add an unmapped drawOP to set tile attributes when RenderFrame() is called
 ex af,af'
 ld a,(CURRENT_DRAW_COUNT)
 ld l,a
 ld c,a
 inc a
 ld (CURRENT_DRAW_COUNT),a
 xor a
 ld h,a
 ld b,a     ;BC = HL = drawOPcode0based
 HL_POW2_2()
 add hl,bc  ;*5
 ld bc,(CURRENT_DRAW_OPS)
 add hl,bc  ;HL = address for new drawOP
 pop bc     ;B = %...11... (BC in ATTRIBUTES)
 WRITE_HL_POINTER(b,c);attributes address
 pop bc
 ld (hl),c
 inc hl
 ld (hl),a
 inc hl
 ld (hl),a  ;drawOP = addressLow,addressHigh,color,0,0

; Create a standard drawOP to draw tile when RenderFrame() is called
; 1. Compute tile source in BC
 ld h,a     ;A = 0
 ex af,af'
 ld l,a
 HL_POW2_3();number*8
 ld bc,(TILE_SET)
 add hl,bc
 ld b,h
 ld c,l     ;BC = tile source
; 2. Check draw map
 ld hl,(CURRENT_DRAW_MAP)
 add hl,de
 ld a,(hl)  ;drawOPcode1based
 and a
 jr z,CREATE_OP;no op at CURRENT_DRAW_MAP
; 3. Compute address for existing drawOP
 ld l,a
 ld e,a
 xor a
 ld h,a
 ld d,a     ;DE = HL = drawOPcode1based
 HL_POW2_2()
 add hl,de  ;*5
 ld de,(CURRENT_DRAW_OPS)
 add hl,de  ;HL = (CDO) + drawOPcode*5 + 5
 dec hl     ;HL = (CDO) + drawOPcode*5 + 4
; 4. If op type is tile clear, then replace old with new tile source
 ld a,(hl)  ;op type (draw op = 1, tile clear op = 2)
 cp 2
 jr nz,CREATE_OP;op type is not tile clear
 dec hl     ;BC = new tile source
 dec hl     ;(HL,HL+1) = old tile source
 WRITE_HL_POINTER(b,c);replace old with new tile source
; 5. Now everything is ready to create drawOP
CREATE_OP:
 pop bc     ;B = x, C = y
 ld hl,EMPTY_CHAR
 jp CREATE_DRAW_OP

ENDP

PROC
GET_TILE:               ;input: de = x, hl = y, trashes de, hl, a

HL_POW2_5()              ;y * 32

add hl, de              ;+ x

ex de, hl

ld hl, TILE_MAP
add hl, de              ;+ tile_map address

ld a, (hl)              ;get tile number

ret
ENDP

#endif

GSPRITES_LIB_END:

end asm


sub InitGFXLib()

asm

    call INIT_GFX_LIB

end asm

end sub

sub ResetGFXLib()

asm

    call RESET_GFX_LIB

end asm

end sub

sub RenderFrame()

asm

    call RENDER_FRAME

end asm

end sub

#ifdef ENABLE_1x1_SPRITES

#ifndef PRECOMPUTED_SPRITES

function fastcall Create1x1Sprite(SpriteAddress as uInteger) as uByte

asm

    push ix
    push iy
    call CREATE_1x1_SPRITE
    pop iy
    pop ix

end asm

end function

#endif

sub fastcall Draw1x1Sprite(SpriteNumber as uByte, X as uByte, Y as uByte)

asm

    exx
    pop hl
    exx
    pop bc
    pop de
    exx
    push hl
    exx

    push ix
    push iy
    call UBYTE_COORDS_TO_BCHL
    call DRAW_1x1_SPRITE
    pop iy
    pop ix

end asm

end sub

#ifdef SPRITE_XY_IN_PIXELS

sub fastcall Draw1x1SpriteWithClipping(SpriteNumber as uByte, X as Integer, Y as Integer)

asm

    pop hl
    pop bc;     X should range between -7 and 255
    pop de;     Y should range between -7 and 191
    push hl
    ld hl,7
    add hl,bc;  HL should be in [0,262]
    push bc
    ld bc,-263; DE=65273
    add hl,bc;  HL should be in [65273,65535] (noCarry)
    pop bc
    ret c;      HL is not good

    ld hl,7
    add hl,de;  HL should be in [0,198]
    push de
    ld de,-199; DE=65337
    add hl,de;  HL should be in [65337,65535] (noCarry)
    pop de
    ret c;      HL is not good

    push ix
    push iy
    call INTEGER_COORDS_TO_BCHL
    call DRAW_1x1_SPRITE
    pop iy
    pop ix

end asm

end sub

#endif

#endif

#ifdef ENABLE_1x2_SPRITES

#ifndef PRECOMPUTED_SPRITES

function fastcall Create1x2Sprite(SpriteAddress as uInteger) as uByte

asm

    push ix
    push iy
    call CREATE_1x2_SPRITE
    pop iy
    pop ix

end asm

end function

#endif

sub fastcall Draw1x2Sprite(SpriteNumber as uByte, X as uByte, Y as uByte)

asm

    exx
    pop hl
    exx
    pop bc
    pop de
    exx
    push hl
    exx
    push ix
    push iy
    ld c, d
    call UBYTE_COORDS_TO_BCHL
    call DRAW_1x2_SPRITE
    pop iy
    pop ix

end asm

end sub

#ifdef SPRITE_XY_IN_PIXELS

sub fastcall Draw1x2SpriteWithClipping(SpriteNumber as uByte, X as Integer, Y as Integer)

asm

    pop hl
    pop bc;     X should range between -7 and 255
    pop de;     Y should range between -15 and 191
    push hl
    ld hl,7
    add hl,bc;  HL should be in [0,262]
    push bc
    ld bc,-263; DE=65273
    add hl,bc;  HL should be in [65273,65535] (noCarry)
    pop bc
    ret c;      HL is not good

    ld hl,15
    add hl,de;  HL should be in [0,206]
    push de
    ld de,-207; DE=65329
    add hl,de;  HL should be in [65329,65535] (noCarry)
    pop de
    ret c;      HL is not good

    push ix
    push iy
    call INTEGER_COORDS_TO_BCHL
    call DRAW_1x2_SPRITE
    pop iy
    pop ix

end asm

end sub

#endif

#endif

#ifdef ENABLE_2x2_SPRITES

#ifndef PRECOMPUTED_SPRITES

function fastcall Create2x2Sprite(SpriteAddress as uInteger) as uByte

asm

    push ix
    push iy
    call CREATE_2x2_SPRITE
    pop iy
    pop ix

end asm

end function

#endif

sub fastcall Draw2x2Sprite(SpriteNumber as uByte, X as uByte, Y as uByte)

asm

    exx
    pop hl
    exx
    pop bc
    pop de
    exx
    push hl
    exx
    push ix
    push iy
    call UBYTE_COORDS_TO_BCHL
    call DRAW_2x2_SPRITE
    pop iy
    pop ix

end asm

end sub

#ifdef SPRITE_XY_IN_PIXELS

sub fastcall Draw2x2SpriteWithClipping(SpriteNumber as uByte, X as Integer, Y as Integer)

asm

    pop hl
    pop bc;     X should range between -15 and 255
    pop de;     Y should range between -15 and 191
    push hl
    ld hl,15
    add hl,bc;  HL should be in [0,270]
    push bc
    ld bc,-271; DE=65265
    add hl,bc;  HL should be in [65265,65535] (noCarry)
    pop bc
    ret c;      HL is not good

    ld hl,15
    add hl,de;  HL should be in [0,206]
    push de
    ld de,-207; DE=65329
    add hl,de;  HL should be in [65329,65535] (noCarry)
    pop de
    ret c;      HL is not good

    push ix
    push iy
    call INTEGER_COORDS_TO_BCHL
    call DRAW_2x2_SPRITE
    pop iy
    pop ix

end asm

end sub

#endif

#endif

sub fastcall CancelOps()

    asm
    xor a
    ld (CURRENT_DRAW_COUNT), a
    ld (CURRENT_CLEAR_COUNT), a
    end asm

end sub

sub ClearScreen(NewInk as uByte, NewPaper as uByte, NewBright as uByte)

    ink NewInk
    paper NewPaper
    bright NewBright
    cls

    asm
    call CLEAR_SCREEN
    end asm

end sub

#ifdef ENABLE_PRINT

sub PrintString(text as string, Color as uInteger, X as uInteger, Y as uInteger)

    Dim buc as uByte
    Dim tmpVal as uByte = len(text)

    #pragma push(string_base)
    #pragma string_base = 0

    for buc = 0 to tmpVal - 1
        PrintChar(code(text(buc to buc)), Color, X + buc - 1, Y)
    next buc

    #pragma pop(string_base)
end sub

sub fastcall PrintChar(CharNumber as uByte, Color as uInteger, X as uInteger, Y as uInteger)

asm
    exx
    pop hl
    exx
    pop bc
    pop de
    pop hl
    exx
    push hl
    exx
    call PRINT_CHAR
end asm

end sub

#endif

#ifdef ENABLE_TILES

sub fastcall SetTileset(TileSet as uInteger)

asm
    call SET_TILEMAP
end asm

end sub

sub fastcall SetTile(TileNumber as uByte, Color as uInteger, X as uInteger, Y as uInteger)

asm
    exx
    pop hl
    exx
    pop bc
    pop de
    pop hl
    exx
    push hl
    exx
    call SET_TILE
end asm

end sub

sub fastcall SetTileColor(X as uInteger, Y as uInteger, Color as uInteger)

asm
    exx
    pop hl
    exx
    pop de
    pop bc
    ex de, hl
    exx
    push hl
    exx
    call SET_TILE_COLOR
end asm

end sub

sub fastcall SetTileChecked(TileNumber as uByte, Attribute as uInteger, X as uInteger, Y as uInteger)

asm
    exx
    pop hl
    exx
    pop bc
    pop de
    pop hl
    exx
    push hl
    exx
    call SET_TILE_CHECKED
end asm

end sub

sub fastcall SetTileAnimated(TileNumber as uByte, Attribute as uInteger, X as uInteger, Y as uInteger)

asm
    exx
    pop hl
    exx
    pop bc
    pop de
    pop hl
    exx
    push hl
    exx
    push ix
    push iy
    call SET_TILE_ANIMATED
    pop iy
    pop ix
end asm

end sub

function fastcall GetTile(X as uInteger, Y as uInteger) as uByte

asm
    pop bc
    pop de
    push bc
    ex de, hl
    call GET_TILE
end asm

end function


function fastcall GetTileColor(X as uInteger, Y as uInteger) as uByte

asm
    pop bc
    pop de
    push bc
    ex de, hl
    call GET_TILE_COLOR
end asm

end function

sub SetTiledObject(ObjectTileIndex as uByte, Width as uByte, Height as uByte, Attribute as uByte, X as uByte, Y as uByte)

    Dim tmpX as uByte
    Dim tmpY as uByte

    for tmpX = X to X + Width - 1
        for tmpY = Y to Y + Height - 1
            SetTile(ObjectTileIndex, Attribute, tmpX, tmpY)
            ObjectTileIndex = ObjectTileIndex + 1
        next tmpY
    next tmpX

end sub

sub FillWithTile(TileIndex as uByte, Width as uByte, Height as uByte, Attribute as uByte, X as uByte, Y as uByte)

    Dim tmpX as uByte
    Dim tmpY as uByte

    for tmpX = X to X + Width - 1
        for tmpY = Y to Y + Height - 1
            SetTile(TileIndex, Attribute, tmpX, tmpY)
        next tmpY
    next tmpX

end sub

sub SetTiledObjectChecked(ObjectTileIndex as uByte, Width as uByte, Height as uByte, Attribute as uByte, X as uByte, Y as uByte)

    Dim tmpX as uByte
    Dim tmpY as uByte

    for tmpX = X to X + Width - 1
        for tmpY = Y to Y + Height - 1
            SetTileChecked(ObjectTileIndex, Attribute, tmpX, tmpY)
            ObjectTileIndex = ObjectTileIndex + 1
        next tmpY
    next tmpX

end sub

sub FillWithTileChecked(TileIndex as uByte, Width as uByte, Height as uByte, Attribute as uByte, X as uByte, Y as uByte)

    Dim tmpX as uByte
    Dim tmpY as uByte

    for tmpX = X to X + Width - 1
        for tmpY = Y to Y + Height - 1
            SetTileChecked(TileIndex, Attribute, tmpX, tmpY)
        next tmpY
    next tmpX

end sub

sub SetTiledObjectAnimated(ObjectTileIndex as uByte, Width as uByte, Height as uByte, Attribute as uByte, X as uByte, Y as uByte)

    Dim tmpX as uByte
    Dim tmpY as uByte

    for tmpX = X to X + Width - 1
        for tmpY = Y to Y + Height - 1
            SetTileAnimated(ObjectTileIndex, Attribute, tmpX, tmpY)
            ObjectTileIndex = ObjectTileIndex + 1
        next tmpY
    next tmpX

end sub

sub FillWithTileAnimated(TileIndex as uByte, Width as uByte, Height as uByte, Attribute as uByte, X as uByte, Y as uByte)

    Dim tmpX as uByte
    Dim tmpY as uByte

    for tmpX = X to X + Width - 1
        for tmpY = Y to Y + Height - 1
            SetTileAnimated(TileIndex, Attribute, tmpX, tmpY)
        next tmpY
    next tmpX

end sub

#endif
